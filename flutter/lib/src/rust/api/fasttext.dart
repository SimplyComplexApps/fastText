// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `handle_result`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `drop`, `eq`, `fmt`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FastText>>
abstract class FastText implements RustOpaqueInterface {
  static Future<FastText> default_() =>
      FastTextLib.instance.api.crateApiFasttextFastTextDefault();

  /// Solves the word analogy problem.
  ///
  /// Solve word analogy problems of the form "A is to B as C is to ?".
  /// For example, "king is to queen as man is to ?". The goal is to find the word that best fits
  /// the question mark (in this case, "woman").
  ///
  /// # Arguments
  ///
  /// * `k` - The number of analogies to return.
  /// * `wordA` - The word A in "A is to B as C is to ?".
  /// * `wordB` - The word B in "A is to B as C is to ?".
  /// * `wordC` - The word C in "A is to B as C is to ?".
  Future<List<(double, String)>> getAnalogies({
    required int k,
    required String wordA,
    required String wordB,
    required String wordC,
  });

  /// Get dimension of the model.
  Future<int> getDimension();

  /// Nearest neighbors for a given word.
  ///
  /// # Arguments
  ///
  /// * `word` - The word to find nearest neighbors for.
  /// * `k` - The number of nearest neighbors to return.
  Future<List<(double, String)>> getNn({required String word, required int k});

  /// Get the vector of a sentence.
  ///
  /// # Arguments
  ///
  /// * `text` - The sentence to get the vector for.
  Future<Float32List> getSentenceVector({required String text});

  /// Get the subword ID of a word.
  ///
  /// # Arguments
  ///
  /// * `word` - The word to get the ID for.
  Future<int> getSubwordId({required String word});

  /// Get the ID of a word.
  ///
  /// # Arguments
  ///
  /// * `word` - The word to get the ID for.
  Future<int> getWordId({required String word});

  /// Get the vector of a word.
  ///
  /// # Arguments
  ///
  /// * `word` - The word to get the vector for.
  Future<Float32List> getWordVector({required String word});

  /// Loads a model from the given path.
  ///
  /// # Arguments
  ///
  /// * `path` - The file path of the model to load.
  Future<void> loadModel({required String path});

  /// Loads a model from a buffer.
  ///
  /// # Arguments
  ///
  /// * `buffer` - A byte slice containing the model data.
  Future<void> loadModelFromBuffer({required List<int> buffer});

  /// Creates a new fastText instance.
  factory FastText() => FastTextLib.instance.api.crateApiFasttextFastTextNew();

  /// Predicts labels for a given text.
  ///
  /// # Arguments
  ///
  /// * `text` - The input text for prediction.
  /// * `k` - The number of top predictions to return.
  /// * `threshold` - The minimum probability for a prediction to be returned.
  Future<List<Prediction>> predict({
    required String text,
    required int k,
    required double threshold,
  });

  /// Saves a model to the given path.
  ///
  /// # Arguments
  ///
  /// * `path` - The file path of where to save the model.
  Future<void> saveModel({required String path});
}

/// Represents a single prediction from the fastText model.
class Prediction {
  final double probability;
  final String label;

  const Prediction({required this.probability, required this.label});

  @override
  int get hashCode => probability.hashCode ^ label.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Prediction &&
          runtimeType == other.runtimeType &&
          probability == other.probability &&
          label == other.label;
}
